#include "editor/yaml_handler.h"

#include <QDateTime>
#include <QDebug>
#include <QFile>
#include <QFileInfo>
#include <QTextStream>

YamlHandler::YamlHandler(QObject* parent) : QObject(parent) {}

bool YamlHandler::saveMap(const QString& filename,
                          const QList<CheckpointItem*>& checkpoints,
                          const QList<HintItem*>& hints,
                          const QList<BuildingItem*>& buildings) {
    QFile file(filename);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qWarning() << "Cannot open file for writing:" << filename;
        return false;
    }

    QTextStream out(&file);

    // Header
    out << "# Need for Speed - Map File\n";
    out << "# Generated by Map Editor\n";
    out << "# " << QDateTime::currentDateTime().toString() << "\n\n";

    // Metadata
    out << "metadata:\n";
    out << "  name: \"Nuevo Recorrido\"\n";
    out << "  author: \"Editor User\"\n";
    out << "  description: \"\"\n";
    out << "  difficulty: Medium\n";
    out << "  recommended_laps: 3\n";
    out << "  created_date: "
        << QDateTime::currentDateTime().toString(Qt::ISODate) << "\n";
    out << "  modified_date: "
        << QDateTime::currentDateTime().toString(Qt::ISODate) << "\n\n";

    // Background - guardar nombre base del archivo YAML + .png
    QFileInfo fileInfo(filename);
    QString backgroundName = fileInfo.baseName() + ".png";
    out << "background_image: " << backgroundName << "\n\n";

    // Start position (primer checkpoint START si existe)
    out << "start_position:\n";
    bool foundStart = false;
    for (CheckpointItem* cp : checkpoints) {
        if (cp->getType() == CheckpointItem::Start) {
            out << "  x: " << cp->pos().x() << "\n";
            out << "  y: " << cp->pos().y() << "\n";
            out << "  rotation: " << cp->getRotation() << "\n";
            foundStart = true;
            break;
        }
    }
    if (!foundStart) {
        out << "  x: 100\n  y: 100\n  rotation: 0\n";
    }

    // Checkpoints
    out << "checkpoints:\n";
    if (checkpoints.isEmpty()) {
        out << "  []\n";
    } else {
        for (CheckpointItem* cp : checkpoints) {
            QString typeStr;
            switch (cp->getType()) {
                case CheckpointItem::Start:
                    typeStr = "start";
                    break;
                case CheckpointItem::Normal:
                    typeStr = "intermediate";
                    break;
                case CheckpointItem::Finish:
                    typeStr = "finish";
                    break;
            }

            out << "  - type: " << typeStr << "\n";
            out << "    x: " << cp->pos().x() << "\n";
            out << "    y: " << cp->pos().y() << "\n";
            out << "    rotation: " << cp->getRotation() << "\n";
            out << "    width: " << cp->getWidth() << "\n";
        }
    }

    // Hints
    out << "hints:\n";
    if (hints.isEmpty()) {
        out << "  []\n";
    } else {
        for (HintItem* hint : hints) {
            out << "  - x: " << hint->pos().x() << "\n";
            out << "    y: " << hint->pos().y() << "\n";
            out << "    rotation: " << hint->getRotation() << "\n";
        }
    }

    // Buildings
    out << "buildings:\n";
    if (buildings.isEmpty()) {
        out << "  []\n";
    } else {
        for (BuildingItem* building : buildings) {
            QList<QPointF> vertices = building->getVertices();

            out << "  - type: " << building->getBuildingType() << "\n";
            out << "    height: " << building->getHeight() << "\n";
            out << "    vertices:\n";

            for (const QPointF& vertex : vertices) {
                out << "      - x: " << vertex.x() << "\n";
                out << "        y: " << vertex.y() << "\n";
            }
        }
    }

    file.close();
    qDebug() << "Map saved:" << filename;
    qDebug() << "  Checkpoints:" << checkpoints.size();
    qDebug() << "  Hints:" << hints.size();
    qDebug() << "  Buildings:" << buildings.size();

    return true;
}

bool YamlHandler::loadMap(const QString& filename, QString& backgroundImagePath,
                          QList<CheckpointItem*>& checkpoints,
                          QList<HintItem*>& hints,
                          QList<BuildingItem*>& buildings) {
    QFile file(filename);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        qWarning() << "Cannot open file for reading:" << filename;
        return false;
    }

    // TODO(nico): Implementar parser YAML completo usando yaml-cpp
    // Por ahora, un parser simplificado

    QTextStream in(&file);
    QString currentSection;
    backgroundImagePath.clear();  // Limpiar path de imagen

    // Variables temporales para construir items
    CheckpointItem* currentCheckpoint = nullptr;
    HintItem* currentHint = nullptr;
    BuildingItem* currentBuilding = nullptr;
    QList<QPointF> buildingVertices;

    while (!in.atEnd()) {
        QString line = in.readLine().trimmed();

        if (line.startsWith("#") || line.isEmpty()) continue;

        // Capturar ruta de imagen de fondo
        if (line.startsWith("background_image:")) {
            backgroundImagePath = line.split(":").last().trimmed();
            // Eliminar comillas si las hay
            backgroundImagePath = backgroundImagePath.remove('"').remove('\'');
            qDebug() << "Found background image path:" << backgroundImagePath;
            continue;
        }

        if (line == "checkpoints:") {
            currentSection = "checkpoints";
            continue;
        } else if (line == "hints:") {
            currentSection = "hints";
            continue;
        } else if (line == "buildings:") {
            currentSection = "buildings";
            continue;
        }

        // Parse checkpoints
        if (currentSection == "checkpoints") {
            if (line.startsWith("- type:")) {
                if (currentCheckpoint) {
                    checkpoints.append(currentCheckpoint);
                }

                QString typeStr = line.split(":").last().trimmed();
                CheckpointItem::CheckpointType type;
                if (typeStr == "start")
                    type = CheckpointItem::Start;
                else if (typeStr == "finish")
                    type = CheckpointItem::Finish;
                else
                    type = CheckpointItem::Normal;

                currentCheckpoint = new CheckpointItem(0, type, QPointF(0, 0));
            } else if (currentCheckpoint) {
                if (line.startsWith("x:")) {
                    float x = line.split(":").last().trimmed().toFloat();
                    currentCheckpoint->setPos(x, currentCheckpoint->pos().y());
                } else if (line.startsWith("y:")) {
                    float y = line.split(":").last().trimmed().toFloat();
                    currentCheckpoint->setPos(currentCheckpoint->pos().x(), y);
                } else if (line.startsWith("rotation:")) {
                    float rot = line.split(":").last().trimmed().toFloat();
                    currentCheckpoint->setRotation(rot);
                } else if (line.startsWith("width:")) {
                    float width = line.split(":").last().trimmed().toFloat();
                    currentCheckpoint->setWidth(width);
                }
            }
        } else if (currentSection == "hints") {
            // Parse hints
            if (line.startsWith("- x:")) {
                if (currentHint) {
                    hints.append(currentHint);
                }
                currentHint = new HintItem(0, QPointF(0, 0));
                float x = line.split(":").last().trimmed().toFloat();
                currentHint->setPos(x, 0);
            } else if (currentHint) {
                if (line.startsWith("y:")) {
                    float y = line.split(":").last().trimmed().toFloat();
                    currentHint->setPos(currentHint->pos().x(), y);
                } else if (line.startsWith("rotation:")) {
                    float rot = line.split(":").last().trimmed().toFloat();
                    currentHint->setRotation(rot);
                }
            }
        } else if (currentSection == "buildings") {
            // Parse buildings
            if (line.startsWith("- type:")) {
                if (currentBuilding) {
                    currentBuilding->setVertices(buildingVertices);
                    currentBuilding->finishBuilding();
                    buildings.append(currentBuilding);
                    buildingVertices.clear();
                }

                currentBuilding = new BuildingItem();
                QString type = line.split(":").last().trimmed();
                currentBuilding->setBuildingType(type);
            } else if (currentBuilding) {
                if (line.startsWith("height:")) {
                    float height = line.split(":").last().trimmed().toFloat();
                    currentBuilding->setHeight(height);
                } else if (line.startsWith("vertices:")) {
                    // Próximas líneas serán vértices
                } else if (line.startsWith("- x:")) {
                    float x = line.split(":").last().trimmed().toFloat();
                    buildingVertices.append(QPointF(x, 0));
                } else if (line.startsWith("y:") &&
                           !buildingVertices.isEmpty()) {
                    float y = line.split(":").last().trimmed().toFloat();
                    buildingVertices.last().setY(y);
                }
            }
        }
    }

    // Agregar últimos items
    if (currentCheckpoint) checkpoints.append(currentCheckpoint);
    if (currentHint) hints.append(currentHint);
    if (currentBuilding) {
        currentBuilding->setVertices(buildingVertices);
        currentBuilding->finishBuilding();
        buildings.append(currentBuilding);
    }

    file.close();

    qDebug() << "Map loaded:" << filename;
    qDebug() << "  Checkpoints:" << checkpoints.size();
    qDebug() << "  Hints:" << hints.size();
    qDebug() << "  Buildings:" << buildings.size();

    return true;
}
