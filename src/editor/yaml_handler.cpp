#include "editor/yaml_handler.h"

#include <QDateTime>
#include <QDebug>
#include <QFile>
#include <QFileInfo>
#include <QTextStream>

#include "editor/building_item.h"
#include "editor/checkpoint_item.h"
#include "editor/overpass_item.h"
#include "editor/sensor_item.h"

YamlHandler::YamlHandler(QObject* parent) : QObject(parent) {}

// --- ACTUALIZAR FIRMA AQUÍ TAMBIÉN ---
bool YamlHandler::saveMap(const QString& filename,
                          const QList<CheckpointItem*>& checkpoints,
                          const QList<BuildingItem*>& buildings,
                          const QList<SensorItem*>& sensors,
                          const QList<OverpassItem*>& overpasses) {
    QFile file(filename);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        qWarning() << "Cannot open file for writing:" << filename;
        return false;
    }

    QTextStream out(&file);

    // Header y Metadata
    out << "# Need for Speed - Map File\n";
    out << "# Generated by Map Editor\n";
    out << "metadata:\n";
    out << "  name: \"Nuevo Recorrido\"\n";
    out << "  created_date: "
        << QDateTime::currentDateTime().toString(Qt::ISODate) << "\n\n";

    // Background
    QFileInfo fileInfo(filename);
    QString backgroundName = fileInfo.baseName() + ".png";
    out << "background_image: " << backgroundName << "\n\n";

    // Start Position
    out << "start_position:\n";
    bool foundStart = false;
    for (CheckpointItem* cp : checkpoints) {
        if (cp->getType() == CheckpointItem::Start) {
            out << "  x: " << cp->pos().x() << "\n";
            out << "  y: " << cp->pos().y() << "\n";
            out << "  rotation: " << cp->getRotation() << "\n";
            foundStart = true;
            break;
        }
    }
    if (!foundStart) out << "  x: 100\n  y: 100\n  rotation: 0\n";

    // Checkpoints
    out << "checkpoints:\n";
    if (checkpoints.isEmpty()) {
        out << "  []\n";
    } else {
        for (CheckpointItem* cp : checkpoints) {
            QString typeStr = (cp->getType() == CheckpointItem::Start) ? "start"
                              : (cp->getType() == CheckpointItem::Finish)
                                  ? "finish"
                                  : "intermediate";
            out << "  - type: " << typeStr << "\n";
            out << "    x: " << cp->pos().x() << "\n";
            out << "    y: " << cp->pos().y() << "\n";
            out << "    rotation: " << cp->getRotation() << "\n";
            out << "    width: " << cp->getWidth() << "\n";
        }
    }

    // Buildings
    out << "buildings:\n";
    if (buildings.isEmpty()) {
        out << "  []\n";
    } else {
        for (BuildingItem* b : buildings) {
            out << "  - type: " << b->getBuildingType() << "\n";
            out << "    vertices:\n";
            for (const QPointF& v : b->getVertices()) {
                out << QString("      - { x: %1, y: %2 }\n")
                           .arg(v.x())
                           .arg(v.y());
            }
        }
    }

    out << "sensors:\n";
    if (sensors.isEmpty()) {
        out << "  upper: []\n";
        out << "  lower: []\n";
    } else {
        // Separar sensores por tipo
        QList<SensorItem*> upperSensors, lowerSensors;
        for (SensorItem* s : sensors) {
            if (s->getSensorType() == SensorItem::Upper)
                upperSensors.append(s);
            else
                lowerSensors.append(s);
        }

        // Helper lambda para escribir vértices
        auto writeSensorsList = [&](const QList<SensorItem*>& list) {
            if (list.isEmpty()) {
                out << " []\n";
                return;
            }
            out << "\n";
            for (SensorItem* s : list) {
                out << "    - vertices:\n";
                for (const QPointF& v : s->getVertices()) {
                    out << QString("      - { x: %1, y: %2 }\n")
                               .arg(v.x())
                               .arg(v.y());
                }
            }
        };

        out << "  upper:";
        writeSensorsList(upperSensors);

        out << "  lower:";
        writeSensorsList(lowerSensors);
    }

    // Overpasses
    out << "overpass:\n";
    if (overpasses.isEmpty()) {
        out << "  []\n";
    } else {
        for (OverpassItem* o : overpasses) {
            out << "  - type: overpass\n";
            out << "    vertices:\n";
            for (const QPointF& v : o->getVertices()) {
                out << QString("      - { x: %1, y: %2 }\n")
                           .arg(v.x())
                           .arg(v.y());
            }
        }
    }

    file.close();
    qDebug() << "Map saved:" << filename;
    return true;
}

bool YamlHandler::loadMap(const QString& filename, QString& backgroundImagePath,
                          QList<CheckpointItem*>& checkpoints,
                          QList<BuildingItem*>& buildings,
                          QList<SensorItem*>& sensors,
                          QList<OverpassItem*>& overpasses) {
    QFile file(filename);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        qWarning() << "Cannot open file for reading:" << filename;
        return false;
    }

    QTextStream in(&file);
    QString currentSection;
    backgroundImagePath.clear();

    // Punteros temporales
    CheckpointItem* currentCheckpoint = nullptr;
    BuildingItem* currentBuilding = nullptr;
    SensorItem* currentSensor = nullptr;
    OverpassItem* currentOverpass = nullptr;

    SensorItem::SensorType currentSensorType = SensorItem::Upper;

    // Helper lambda para parsear una línea tipo "- { x: 10, y: 20 }"
    auto parseVertex = [](const QString& line) -> QPointF {
        QString clean = line;
        clean = clean.remove("-").remove("{").remove("}").trimmed();
        QStringList parts = clean.split(",");
        float x = 0, y = 0;
        for (QString part : parts) {
            part = part.trimmed();
            if (part.startsWith("x:")) x = part.mid(2).toFloat();
            if (part.startsWith("y:")) y = part.mid(2).toFloat();
        }
        return QPointF(x, y);
    };

    // Función auxiliar para guardar y limpiar el sensor actual
    auto flushCurrentSensor = [&]() {
        if (currentSensor) {
            currentSensor->finish();  // Cerrar el polígono
            sensors.append(currentSensor);
            currentSensor = nullptr;
        }
    };

    auto flushCurrentOverpass = [&]() {
        if (currentOverpass) {
            currentOverpass->finish();
            overpasses.append(currentOverpass);
            currentOverpass = nullptr;
        }
    };

    while (!in.atEnd()) {
        QString line = in.readLine().trimmed();

        if (line.startsWith("#") || line.isEmpty()) continue;

        // --- DETECTAR SECCIONES ---
        if (line.startsWith("background_image:")) {
            backgroundImagePath =
                line.split(":").last().trimmed().remove('"').remove('\'');
            continue;
        }

        // Si cambia de sección principal, limpiamos cualquier objeto pendiente
        if (line == "checkpoints:") {
            flushCurrentSensor();
            currentSection = "checkpoints";
            continue;
        }
        if (line == "buildings:") {
            flushCurrentSensor();
            currentSection = "buildings";
            continue;
        }
        if (line == "sensors:") {
            // NO flush aquí, porque puede venir de buildings, pero por
            // seguridad:
            currentBuilding = nullptr;
            currentSection = "sensors";
            continue;
        }
        if (line == "overpass:") {
            flushCurrentSensor();
            currentSection = "overpass";
            continue;
        }

        // --- LÓGICA CHECKPOINTS ---
        if (currentSection == "checkpoints") {
            if (line.startsWith("- type:")) {
                if (currentCheckpoint) {
                    checkpoints.append(currentCheckpoint);
                }

                QString typeStr = line.split(":").last().trimmed();
                CheckpointItem::CheckpointType type = CheckpointItem::Normal;
                if (typeStr == "start") {
                    type = CheckpointItem::Start;
                } else if (typeStr == "finish") {
                    type = CheckpointItem::Finish;
                }

                currentCheckpoint = new CheckpointItem(0, type, QPointF(0, 0));
            } else if (currentCheckpoint) {
                if (line.startsWith("x:")) {
                    currentCheckpoint->setPos(line.split(":").last().toFloat(),
                                              currentCheckpoint->y());
                }
                if (line.startsWith("y:")) {
                    currentCheckpoint->setPos(currentCheckpoint->x(),
                                              line.split(":").last().toFloat());
                }
                if (line.startsWith("rotation:")) {
                    currentCheckpoint->setRotation(
                        line.split(":").last().toFloat());
                }
                if (line.startsWith("width:")) {
                    currentCheckpoint->setWidth(
                        line.split(":").last().toFloat());
                }
            }
        } else if (currentSection == "buildings") {
            if (line.startsWith("- type:")) {
                if (currentBuilding) {
                    currentBuilding->finishBuilding();
                    buildings.append(currentBuilding);
                }
                currentBuilding = new BuildingItem();
                currentBuilding->setBuildingType(
                    line.split(":").last().trimmed());
            } else if (line.startsWith("- {") && currentBuilding) {
                // Agregar vértice DIRECTAMENTE al objeto
                currentBuilding->addVertex(parseVertex(line));
            }
        } else if (currentSection == "sensors") {
            // Si detectamos cambio de tipo Upper/Lower
            if (line.startsWith("upper:")) {
                flushCurrentSensor();  // Guardar el anterior si existía
                currentSensorType = SensorItem::Upper;
                continue;
            } else if (line.startsWith("lower:")) {
                flushCurrentSensor();  // Guardar el anterior si existía
                currentSensorType = SensorItem::Lower;
                continue;
            }

            // Inicio de un nuevo sensor individual
            if (line.startsWith("- vertices:")) {
                flushCurrentSensor();  // Guardar el sensor anterior
                currentSensor = new SensorItem(currentSensorType);
            } else if (line.startsWith("- {") && currentSensor) {  // Vértice
                currentSensor->addVertex(parseVertex(line));
            }
        } else if (currentSection == "overpass") {
            if (line.startsWith("- type: overpass")) {
                flushCurrentOverpass();
                currentOverpass = new OverpassItem();
            } else if (line.startsWith("- {") && currentOverpass) {
                currentOverpass->addVertex(parseVertex(line));
            }
        }
    }

    // --- GUARDAR PENDIENTES AL FINAL DEL ARCHIVO ---
    if (currentCheckpoint) checkpoints.append(currentCheckpoint);

    if (currentBuilding) {
        currentBuilding->finishBuilding();
        buildings.append(currentBuilding);
    }

    flushCurrentSensor();  // Guardar el último sensor si quedó colgado
    flushCurrentOverpass();

    file.close();
    qDebug() << "Map loaded:" << filename;
    return true;
}
