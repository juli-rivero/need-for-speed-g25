@startuml
skinparam classAttributeIconSize 0

' ===== TIPOS BÁSICOS / ENUMS =====
enum MatchState {
  Starting
  Racing
  Intermission
  Finished
}

enum RaceState {
  Countdown
  Running
  Finished
}

enum TurnDirection {
  None
  Left
  Right
}

class PlayerInput {
  +accelerate : bool
  +brake : bool
  +nitro : bool
  +turn : TurnDirection
}

class RaceDefinition {
  +city : CityId
  +mapFile : string
}

class CityDefinition {
  +name : CityId
  +races : vector<RaceDefinition>
}

class PlayerConfig {
  +id : PlayerId
  +name : string
  +carTypeName : string
}

class PlayerResult {
  +id : PlayerId
  +rawTime : float
  +penalty : float
  +netTime : float
  +dnf : bool
}

class UpgradeChoice {
  +stat : string
  +delta : float
  +penalty : float
}

class RaceProgressSnapshot {
  +playerId : PlayerId
  +nextCheckpoint : int
  +finished : bool
  +disqualified : bool
  +elapsedTime : float
}

class CarSnapshot {
  +type : CarSpriteType
  +x : float
  +y : float
  +vx : float
  +vy : float
  +angle : float
  +speed : float
  +health : float
  +nitroActive : bool
  +braking : bool
  +accelerating : bool
}

class PlayerSnapshot {
  +id : PlayerId
  +name : string
  +car : CarSnapshot
  +raceProgress : RaceProgressSnapshot
}

class CollisionEvent {
  +type : CollisionType
  +carA : PlayerId
  +carB : PlayerId
  +intensity : float
}

class WorldSnapshot {
  +time : float
  +raceCity : string
  +raceMapFile : string
  +matchState : MatchState
  +currentRaceIndex : uint32_t
  +raceState : RaceState
  +raceElapsed : float
  +raceCountdown : float
  +raceTimeLeft : float
  +players : vector<PlayerSnapshot>
  +collisions : vector<CollisionEvent>
  +permanentlyDQ : vector<PlayerId>
}

class WallInfo {
  +id : int
  +x : float
  +y : float
  +w : float
  +h : float
}

class CheckpointInfo {
  +id : int
  +order : int
  +x : float
  +y : float
  +w : float
  +h : float
}

class HintInfo {
  +id : int
  +x : float
  +y : float
}

class SpawnPointInfo {
  +id : int
  +x : float
  +y : float
  +angle : float
}

class BridgeInfo {
  +id : int
  +lowerX : float
  +lowerY : float
  +upperX : float
  +upperY : float
  +w : float
  +h : float
  +driveable : bool
}

class StaticSnapshot {
  +mapName : string
  +cityName : string
  +walls : vector<WallInfo>
  +bridges : vector<BridgeInfo>
  +checkpoints : vector<CheckpointInfo>
  +hints : vector<HintInfo>
  +spawns : vector<SpawnPointInfo>
  +cars : vector<CarStaticInfo>
}

' ===== CLASES DE CONFIG / WORLD / MODEL BÁSICO =====

class YamlGameConfig {
  -root : YAML::Node
  -penalties : unordered_map<string,float>
  -cities : vector<CityDefinition>
  -carTypes : vector<CarType>
  -maxPlayers : int
  -timeLimitSec : float
  -intermissionSec : float
  +getRaces(city: CityId) : vector<RaceDefinition>&
  +getCarTypes() : vector<CarType>&
  +getPenalties() : unordered_map<string,float>&
}

class Box2DPhysicsWorld
class Car
class Checkpoint
class Wall
class Bridge
class Player
class Thread
class SpawnPoint {
  +x : float
  +y : float
  +angle : float
}

' ===== LÓGICA DE CARRERA / MATCH / GAME =====

class PlayerRaceData {
  +id : PlayerId
  +car : shared_ptr<Car>
  +nextCheckpoint : size_t
  +finished : bool
  +disqualified : bool
  +elapsed : float
  +penaltyTime : float
}

class RaceSession {
  -_cfg : YamlGameConfig&
  -_city : CityId
  -_state : RaceState
  -_raceClock : float
  -_countdownTime : float
  -_checkpoints : vector<unique_ptr<Checkpoint>>
  -_players : vector<PlayerRaceData>
  -_spawnPoints : vector<SpawnPoint>
  +start()
  +update(dt: float)
  +isFinished() : bool
  +makeResults() : vector<PlayerResult>
  +nextCheckpointFor(p: PlayerId) : Checkpoint*
  +onCheckpointCrossed(player: PlayerId, checkpointOrder: int)
  +onCarDestroyed(player: PlayerId)
  +getCheckpoints() : vector<unique_ptr<Checkpoint>>&
  +getPlayerStates() : vector<PlayerRaceData>&
  +getProgressForPlayer(id: PlayerId) : RaceProgressSnapshot
  +getCars() : vector<shared_ptr<Car>>&
  +getSpawnPoints() : vector<SpawnPoint>&
}

class UpgradeSystem {
  -_cfg : YamlGameConfig&
  +applyForNextRace(
    upsByPlayer: unordered_map<PlayerId, vector<UpgradeChoice>>
  ) : unordered_map<PlayerId,float>
}

class MatchSession {
  -_cfg : YamlGameConfig&
  -_world : Box2DPhysicsWorld&
  -_walls : vector<unique_ptr<Wall>>
  -_bridges : vector<unique_ptr<Bridge>>
  -_playerConfigs : vector<PlayerConfig>
  -_players : unordered_map<PlayerId, unique_ptr<Player>>
  -_state : MatchState
  -_races : vector<RaceDefinition>
  -_currentRace : size_t
  -_race : unique_ptr<RaceSession>
  -_intermissionClock : float
  -_totalTime : unordered_map<PlayerId,float>
  -_queuedUpgrades : unordered_map<PlayerId, vector<UpgradeChoice>>
  -_penaltiesForNextRace : unordered_map<PlayerId,float>
  -permanentlyDisqualified : unordered_set<PlayerId>
  -_lastResults : vector<PlayerResult>
  -_upgradeSystem : UpgradeSystem
  +start()
  +update(dt: float)
  +applyInput(id: PlayerId, input: PlayerInput)
  +getSnapshot() : WorldSnapshot
  +getStaticSnapshot() : StaticSnapshot
  +queueUpgrades(ups: unordered_map<PlayerId, vector<UpgradeChoice>>)
  +totals() : unordered_map<PlayerId,float>&
  +state() : MatchState
  +lastRaceResults() : vector<PlayerResult>&
  +getWalls() : vector<unique_ptr<Wall>>&
  +getBridges() : vector<unique_ptr<Bridge>>&
}

class GameSessionFacade {
  -world : Box2DPhysicsWorld
  -config : YamlGameConfig&
  -match : unique_ptr<MatchSession>
  -inputStates : unordered_map<PlayerId, PlayerInput>
  +start(races: vector<RaceDefinition>, players: vector<PlayerConfig>)
  +run()
  +onPlayerEvent(id: PlayerId, event: string)
  +getSnapshot() : WorldSnapshot
  +getStaticSnapshot() : StaticSnapshot
  +stop()
}

class MapLoader {
  +loadFromYAML(
    yamlPath: string,
    world: Box2DPhysicsWorld&,
    walls: vector<unique_ptr<Wall>>&,
    bridges: vector<unique_ptr<Bridge>>&,
    checkpoints: vector<unique_ptr<Checkpoint>>&,
    spawnPoints: vector<SpawnPoint>&
  ) : MapInfo
}

class MapInfo {
  +name : string
  +city : string
  +gravity : b2Vec2
}

' ===== HERENCIAS =====
GameSessionFacade -|> Thread

' ===== RELACIONES PRINCIPALES =====

' Config y tipos de alto nivel
YamlGameConfig --> CityDefinition : <<defines>>
YamlGameConfig --> RaceDefinition : <<provides>>
YamlGameConfig --> CarType : <<provides>>
YamlGameConfig --> UpgradeChoice : <<penalties>>

' GameSessionFacade coordina todo
GameSessionFacade *-- MatchSession
GameSessionFacade *-- Box2DPhysicsWorld
GameSessionFacade --> YamlGameConfig
GameSessionFacade --> PlayerInput
GameSessionFacade ..> RaceDefinition
GameSessionFacade ..> PlayerConfig
GameSessionFacade ..> WorldSnapshot
GameSessionFacade ..> StaticSnapshot

' MatchSession administra un match con N carreras
MatchSession --> YamlGameConfig
MatchSession --> Box2DPhysicsWorld
MatchSession *-- RaceSession
MatchSession *-- Wall
MatchSession *-- Bridge
MatchSession *-- Player
MatchSession --> PlayerConfig
MatchSession --> RaceDefinition
MatchSession --> PlayerInput
MatchSession --> PlayerResult
MatchSession --> UpgradeSystem
MatchSession ..> UpgradeChoice
MatchSession ..> WorldSnapshot
MatchSession ..> StaticSnapshot

' RaceSession administra 1 carrera concreta
RaceSession --> YamlGameConfig
RaceSession *-- Checkpoint
RaceSession --> Car
RaceSession --> SpawnPoint
RaceSession --> PlayerRaceData
RaceSession --> PlayerResult
RaceSession --> RaceProgressSnapshot

' UpgradeSystem usa config y UpgradeChoice
UpgradeSystem --> YamlGameConfig
UpgradeSystem --> UpgradeChoice

' MapLoader construye el mundo estático desde YAML
MapLoader ..> Box2DPhysicsWorld
MapLoader ..> Wall
MapLoader ..> Bridge
MapLoader ..> Checkpoint
MapLoader ..> SpawnPoint
MapLoader ..> MapInfo

@enduml
